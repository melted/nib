Let's make a BNF grammar

Program := decl*
decl := `module` name | `use` name | binding
binding := binding_lhs [`|` expr] `=` expr
binding_lhs := pattern | name pattern+ | pattern binop pattern | `do`
pattern := literal | name | `_` | `[` [pattern `,`]* pattern `]` |
          pattern `@` identifier | `(` name pattern+ `)` | name `...`
  
expr := literal | identifier | expr (expr)+ | expr binop expr | `(` expr `)` | `[` (expr `,`)* expr `]` |
        `{` ((clause semi)* clause | expr ) `}` | expr `where` (binding semi) binding | expr `=>` expr semi expr |
        expr `.` expr 

semi := `;` | <newline>

clause := pattern+ [`|` expr] `->` expr

literal = nil | `true` | `false` | string | char |
          number | symbol | `#[` (u8 `,`) u8 `]`


nil = `nil` | `()`

identifier = (alpha | `_`) (alphanum | `_`)* and not in reserved_words
| `(` binop `)`

binop = opchar+ not in reserved | `\`` name `\`` 

name = (identifier `.`)* identifier
qbinop = (identifier `.`)* binop

symbolchar = unicode symbol except '{} [] ().,;#'
reserved_symbols = `=` `@` `->` `_` `=>` '|' 
reserved_words = `module` | `use` | `where` | `_`