Let's make a BNF grammar

Program := decl*
decl := `module` name | `use` name | binding
binding := binding_lhs `=` expr
binding_lhs := pattern | name pattern+ | pattern binop pattern | `do`
pattern := literal | identifier | `_` | `[` [pattern `,`]* pattern `]` |
          pattern `@` identifier | `(` name pattern+ `)` | identifier `...` |
          `(` pattern `)`
  
expr := literal | name | expr (expr)+ | expr binop expr | `(` expr `)` | `[` (expr `,`)* expr `]` |
        `{` (clause `;`)* clause `}` | expr `where` (binding `;`) binding | expr `?` expr `;` expr

clause := [pattern+ `->`] expr

literal = nil | `true` | `false` | string | char |
          number | symbol | `#[` (u8 `,`) u8 `]`


nil = `nil` | `()`
identifier = (alpha | `_`) (alphanum | `_`)*
binop = symbolchar+ not in reserved | `\`` name `\`` 

name = (identifier `.`)* identifier
qbinop = (identifier `.`)* binop

symbolchar = unicode symbol except '{} [] ().,;'
reserved = `=` `@` `->` 
