// The default library for Nib

module global

/// Abort immediately with an error value. The value will be converted to a string.
panic = _prim_panic

/// Exit with an exit code, the argument must be an integer. Only the lower 32 bits of the
/// argument will be used.
exit = _prim_exit

/// Add two numbers
a + b = _prim_add a b

/// Subtract b from a
a - b = _prim_sub a b

/// Multiply two numbers
a * b = _prim_mul a b

/// Divide a by b
a / b = _prim_div a b
mod a b = _prim_mod a b

a > b = _prim_gt a b
a >= b = _prim_gte a b
a < b = _prim_lt a b
a <= b = _prim_lte a b

a == b = _prim_eq a b
a != b = not (a == b)

not true = false
not false = true

// bitops
bit_and = _prim_bitand
bit_or = _prim_bitor
bit_xor = _prim_bitxor
bit_not = _prim_bitnot
bit_shift = _prim_bitshift

// some arithmetic
max x y = x > y => x; y
min x y = x < y => x; y

// logic
x || y = x => x; y ()
x && y = x => y (); false

// convenience
on x f = f x
id x = x

/// Sequencing operator. The arguments are evaluated in order and the right argument
/// is returned.
a & b = b
const a b = a
apply = _prim_apply

// types
type = _prim_type
generic_matcher t v | (type v == t) = [v]
generic_matcher _ _ = false

make_type type_sym name = new where
                                new = table.create
                                _ = table.set global type_sym new
                                _ = table.set new #type_id name
                                _ = table.set new #match (generic_matcher type_sym)

type_name v = (type v).type_id
set_type = _prim_type_set

// IO
print a = _prim_string_print (_prim_to_string a)
println a =  print a & print "\n"

// Stuff that need prims
// =====================
// apply
// +, -, *, /, mod (at least type specific ones, maybe can do generic as lib)
// <, >, <=, >=, == - check
// sin, cos, tan, asin, acos, atan
// and, or, xor, lsh, rsh, (bit logic)
// type, set_type
// array (ref, set, new, size) - check
// bytearray (ref, set, new, size, 8-64bit ops signed unsigned) 
// symbol (new, new_well_known)
// table (create, ref, set, size)
// char (ord, chr, char array from/to bytes)
// ptr (peek, poke, offset) -- can wait
// IO (print, println, put_char, get_char. stdin. stderr, stdout, filehandling(file_open, file_close)) 
// Debug
//
// Stuff that doesn't need primitives
// ==================================
//
//
//

// Array functions
array.ref = _prim_array_ref  
array.set = _prim_array_set
array.size = _prim_array_size
array.create = _prim_array_create
array.for_each f arr = iter 0 where
                            len = array.size arr
                            iter n | n == len = ()
                            iter n = f n (array.ref arr n) & iter (n+1)

array.map f arr = out where
                        len = array.size arr
                        out = array.create len
                        go n | n == len = ()
                        go n = array.set out n (f (array.ref arr n)) & go (n+1)
                        _ = go 0

array.concat x y = merged where
                        xs = array.size x
                        ys = array.size y
                        cs = xs + ys
                        merged = array.create cs
                        go n | n == cs = ()
                        go n | n < xs = array.set merged n (array.ref x n) & go (n + 1)
                        go n = array.set merged n (array.ref y (n - xs)) & go (n + 1)
                        _ = go 0



a ++ b = (type a).concat a b

// Type matchers for type patterns
array.match v | (type v == array) = [v]
array.match _ = false

int.match v | (type v == int) = [v]
int.match _ = false

// TODO: this doesn't work, figure out why
//int.match v = generic_matcher int v

float.match v | (type v == float) = [v]
float.match _ = false

char.match v | (type v == char) = [v]
char.match _ = false

bool.match v | (type v == bool) = [v]
bool.match _ = false

table.match v | (type v == table) = [v]
table.match _ = false

bytes.match v | (type v == bytes) = [v]
bytes.match _ = false

symbol.match v | (type v == symbol) = [v]
symbol.match _ = false

function.match v | (type v == function) = [v]
function.match _ = false